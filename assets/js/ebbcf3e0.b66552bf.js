"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[625],{2061:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/hz2-b70b95941b3aa6209fc820984c0eb2e8.jpg"},2921:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>o,frontMatter:()=>l,metadata:()=>t,toc:()=>h});const t=JSON.parse('{"id":"lb335/hz2-architecture","title":"HZ2 - Planung und Architektur","description":"Planung und Architektur der mobilen Applikation mit MVVM-Pattern","source":"@site/docs/lb335/hz2-architecture.md","sourceDirName":"lb335","slug":"/lb335/hz2-architecture","permalink":"/lb335/docs/lb335/hz2-architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/reazndev/lb335/docs/lb335/hz2-architecture.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"HZ2 - Planung und Architektur","description":"Planung und Architektur der mobilen Applikation mit MVVM-Pattern"},"sidebar":"tutorialSidebar","previous":{"title":"HZ1 - UI/UX Prototyping","permalink":"/lb335/docs/lb335/hz1-uiux-prototyping"},"next":{"title":"HZ3 - Implementation","permalink":"/lb335/docs/lb335/hz3-implementation"}}');var r=i(4848),s=i(8453);const l={sidebar_position:2,title:"HZ2 - Planung und Architektur",description:"Planung und Architektur der mobilen Applikation mit MVVM-Pattern"},d="Handlungsziel 2: Planung und Architektur der mobilen Applikation",c={},h=[{value:"Architektur-\xdcbersicht",id:"architektur-\xfcbersicht",level:2},{value:"Begr\xfcndung des gew\xe4hlten Applikationstyps",id:"begr\xfcndung-des-gew\xe4hlten-applikationstyps",level:2},{value:"Planung der Datenspeicherung",id:"planung-der-datenspeicherung",level:2},{value:"Gespeicherte Datenstrukturen",id:"gespeicherte-datenstrukturen",level:3},{value:"Speicher-Strategie",id:"speicher-strategie",level:3},{value:"Planung der Gestiksteuerung",id:"planung-der-gestiksteuerung",level:2},{value:"Touch Gesten (Basic Interaction)",id:"touch-gesten-basic-interaction",level:3},{value:"Shake-to-Undo (Accelerometer)",id:"shake-to-undo-accelerometer",level:3},{value:"Scroll Gesten",id:"scroll-gesten",level:3},{value:"Planung Sensoren und Aktoren",id:"planung-sensoren-und-aktoren",level:2},{value:"\xdcbersicht geplanter Sensoren und Aktoren",id:"\xfcbersicht-geplanter-sensoren-und-aktoren",level:3},{value:"Begr\xfcndung der Wahl",id:"begr\xfcndung-der-wahl",level:3},{value:"Interaktions-Szenarien",id:"interaktions-szenarien",level:3},{value:"Technische Integration (Planung)",id:"technische-integration-planung",level:3},{value:"Erkl\xe4rung des Artefakts",id:"erkl\xe4rung-des-artefakts",level:2},{value:"Kritische Beurteilung",id:"kritische-beurteilung",level:2},{value:"The good",id:"the-good",level:3},{value:"The bad",id:"the-bad",level:3},{value:"Fazit",id:"fazit",level:2}];function a(e){const n={h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"handlungsziel-2-planung-und-architektur-der-mobilen-applikation",children:"Handlungsziel 2: Planung und Architektur der mobilen Applikation"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Architektur-Diagramm"}),"\n",(0,r.jsx)(n.li,{children:"Technologie-Stack Dokumentation"}),"\n",(0,r.jsx)(n.li,{children:"Datenmodell und Speicherkonzept"}),"\n",(0,r.jsx)(n.li,{children:"Sensor- und Gestensteuerungskonzept"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"architektur-\xfcbersicht",children:"Architektur-\xdcbersicht"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Architektur \xdcbersicht",src:i(2061).A+"",width:"3000",height:"4000"})}),"\n",(0,r.jsx)(n.h2,{id:"begr\xfcndung-des-gew\xe4hlten-applikationstyps",children:"Begr\xfcndung des gew\xe4hlten Applikationstyps"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Gew\xe4hlter Typ: Native Mobile App mit Expo/React Native"})}),"\n",(0,r.jsx)(n.p,{children:"F\xfcr die Entwicklung nutze ich Expo und React Native, damit die App mit einer einzigen Codebasis sowohl auf iOS als auch auf Android l\xe4uft. Die Expo Go App erm\xf6glicht mir schnelles Testen w\xe4hrend der Entwicklung. Die App greift auf native Funktionen wie den Accelerometer f\xfcr Shake-Gesten und haptisches Feedback zu. Durch lokale Datenspeicherung funktioniert sie auch offline, und native UI-Komponenten sorgen f\xfcr ein plattformspezifisches Aussehen."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Technische Vorteile:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cross-Platform Entwicklung mit einer Codebasis"}),"\n",(0,r.jsx)(n.li,{children:"Zugriff auf native Sensoren (Accelerometer, Kamera)"}),"\n",(0,r.jsx)(n.li,{children:"Haptisches Feedback und Vibration"}),"\n",(0,r.jsx)(n.li,{children:"Lokale Datenspeicherung f\xfcr Offline-Funktionalit\xe4t"}),"\n",(0,r.jsx)(n.li,{children:"Schnelle Entwicklung durch Hot-Reload"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Alternative Optionen und deren Ablehnung:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Native (Swift/Kotlin): Doppelter Entwicklungsaufwand f\xfcr beide Plattformen und neue Programmiersprachen (jetzt w\xfcrde ich mich allerdings dazu entscheiden (zumindestens Kotlin) da ich mich bei der ZKB beworben habe und sie teilweise Kotlin benutzen)"}),"\n",(0,r.jsx)(n.li,{children:"Dotnet Maui: Ich mag kein C# und kenne React bereits"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"planung-der-datenspeicherung",children:"Planung der Datenspeicherung"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Gew\xe4hlte L\xf6sung: AsyncStorage (Key-Value Storage)"})}),"\n",(0,r.jsx)(n.p,{children:"AsyncStorage ist eine asynchrone, persistente Key-Value-Speicherl\xf6sung f\xfcr React Native Apps. Sie erm\xf6glicht einfache lokale Datenspeicherung ohne komplexe Datenbank-Setup."}),"\n",(0,r.jsx)(n.h3,{id:"gespeicherte-datenstrukturen",children:"Gespeicherte Datenstrukturen"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"1. Game State (Spielstand):"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Aktuelles verf\xfcgbares Budget"}),"\n",(0,r.jsx)(n.li,{children:"Liste der gekauften Items mit Details (Name, Preis, Kategorie)"}),"\n",(0,r.jsx)(n.li,{children:"Gesamt ausgegebener Betrag"}),"\n",(0,r.jsx)(n.li,{children:"Spielstatus (l\xe4uft/abgeschlossen)"}),"\n",(0,r.jsx)(n.li,{children:"Zeitstempel f\xfcr Spielstart und -ende"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"2. Statistiken (Langzeitdaten):"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Anzahl gespielter Spiele"}),"\n",(0,r.jsx)(n.li,{children:"Durchschnittliche Items pro Spiel"}),"\n",(0,r.jsx)(n.li,{children:"Total ausgegebenes Geld \xfcber alle Spiele"}),"\n",(0,r.jsx)(n.li,{children:"Total gekaufte Items"}),"\n",(0,r.jsx)(n.li,{children:"Teuerstes jemals gekauftes Item"}),"\n",(0,r.jsx)(n.li,{children:"Lieblingskategorie"}),"\n",(0,r.jsx)(n.li,{children:"Schnellste Completion-Zeit"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"speicher-strategie",children:"Speicher-Strategie"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Auto-Save Konzept:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Nach jedem Kauf wird der Spielstand automatisch persistiert"}),"\n",(0,r.jsx)(n.li,{children:"Bei jedem Verkauf wird der Spielstand aktualisiert"}),"\n",(0,r.jsx)(n.li,{children:"Statistiken werden inkrementell nach jedem Spielabschluss aktualisiert"}),"\n",(0,r.jsx)(n.li,{children:'Keine manuellen "Speichern"-Buttons n\xf6tig'}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Datenwiederherstellung:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Beim App-Start werden gespeicherte Daten automatisch geladen"}),"\n",(0,r.jsx)(n.li,{children:"Falls keine Daten vorhanden sind, wird ein neuer Spielstand initialisiert"}),"\n",(0,r.jsx)(n.li,{children:"Zeitstempel werden beim Laden wieder in Date-Objekte konvertiert"}),"\n",(0,r.jsx)(n.li,{children:"Fehlerhafte Daten f\xfchren zu einem sauberen Reset"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Vorteile der gew\xe4hlten L\xf6sung:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Funktioniert komplett offline ohne Internetverbindung"}),"\n",(0,r.jsx)(n.li,{children:"Schnelle Lese- und Schreiboperationen"}),"\n",(0,r.jsx)(n.li,{children:"Einfache Implementierung ohne komplexe Datenbank"}),"\n",(0,r.jsx)(n.li,{children:"Daten bleiben privat auf dem Ger\xe4t"}),"\n",(0,r.jsx)(n.li,{children:"Keine Server-Kosten oder Backend-Infrastruktur n\xf6tig"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"planung-der-gestiksteuerung",children:"Planung der Gestiksteuerung"}),"\n",(0,r.jsx)(n.h3,{id:"touch-gesten-basic-interaction",children:"Touch Gesten (Basic Interaction)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tap-Geste:"}),"\nDie grundlegende Interaktion erfolgt \xfcber einfache Tap-Gesten. Buttons werden durch Antippen aktiviert, wobei die Aktion erst beim Loslassen des Fingers ausgel\xf6st wird (onTouchEnd statt onTouchStart). Dies verhindert versehentliche K\xe4ufe beim Scrollen."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Anwendungsbereich:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Items kaufen"}),"\n",(0,r.jsx)(n.li,{children:"Einstellungen \xe4ndern"}),"\n",(0,r.jsx)(n.li,{children:"Tab-Navigation"}),"\n",(0,r.jsx)(n.li,{children:"Dialoge best\xe4tigen"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"shake-to-undo-accelerometer",children:"Shake-to-Undo (Accelerometer)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Konzept:"}),"\nEine besondere Funktion ist die Shake-Geste zum R\xfcckg\xe4ngigmachen des letzten Kaufs. Der Beschleunigungssensor misst kontinuierlich die Bewegung des Ger\xe4ts in drei Achsen (x, y, z)."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Funktionsweise:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Der Sensor misst 10 Mal pro Sekunde (100ms Intervall)"}),"\n",(0,r.jsx)(n.li,{children:"Aus den x-, y- und z-Werten wird die Gesamtbeschleunigung berechnet"}),"\n",(0,r.jsx)(n.li,{children:"\xdcberschreitet diese einen Schwellenwert von 1,5G, wird ein Shake erkannt"}),"\n",(0,r.jsx)(n.li,{children:"Ein Cooldown von 1 Sekunde verhindert versehentliche Mehrfach-Ausl\xf6sungen"}),"\n",(0,r.jsx)(n.li,{children:"Nach erkanntem Shake wird der letzte Kauf r\xfcckg\xe4ngig gemacht"}),"\n",(0,r.jsx)(n.li,{children:"Ein Popup informiert den User \xfcber die erfolgreiche Undo-Aktion"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Vorteile:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Intuitive, nat\xfcrliche Geste"}),"\n",(0,r.jsx)(n.li,{children:"Kein zus\xe4tzlicher UI-Button n\xf6tig"}),"\n",(0,r.jsx)(n.li,{children:"Schneller als durch Men\xfcs zu navigieren"}),"\n",(0,r.jsx)(n.li,{children:"Macht Spass und ist interaktiv"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"scroll-gesten",children:"Scroll Gesten"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Vertikales Scrollen:"}),"\nDie Item-Liste l\xe4sst sich vertikal durchscrollen. Die Liste zeigt alle verf\xfcgbaren Items an und erm\xf6glicht fl\xfcssiges Scrollen durch die Kategorien. Eine Scrollbar zeigt die aktuelle Position in der Liste an."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Eigenschaften:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Smooth Scrolling f\xfcr angenehme User Experience"}),"\n",(0,r.jsx)(n.li,{children:"Momentum Scrolling (Liste scrollt nach Swipe noch weiter)"}),"\n",(0,r.jsx)(n.li,{children:"Bounce-Effekt am Anfang und Ende der Liste (iOS-typisch)"}),"\n",(0,r.jsx)(n.li,{children:"Sichtbare Scrollbar zur Orientierung"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Anwendung:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Durchsuchen aller verf\xfcgbaren Items"}),"\n",(0,r.jsx)(n.li,{children:"Navigation durch gekaufte Items in der Statistik"}),"\n",(0,r.jsx)(n.li,{children:"Scrollen durch Kategorien"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Gestik-Konzept \xdcbersicht:"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Geste"}),(0,r.jsx)(n.th,{children:"Aktion"}),(0,r.jsx)(n.th,{children:"Feedback"}),(0,r.jsx)(n.th,{children:"Besonderheit"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Tap"})}),(0,r.jsx)(n.td,{children:"Item kaufen, Buttons aktivieren"}),(0,r.jsx)(n.td,{children:"Haptisches Feedback + Vibration"}),(0,r.jsx)(n.td,{children:"onTouchEnd statt onTouchStart"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Shake"})}),(0,r.jsx)(n.td,{children:"Letzten Kauf r\xfcckg\xe4ngig"}),(0,r.jsx)(n.td,{children:"Vibration + Alert-Anzeige"}),(0,r.jsx)(n.td,{children:"1,5G Threshold, 1s Cooldown"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Scroll"})}),(0,r.jsx)(n.td,{children:"Liste durchbl\xe4ttern"}),(0,r.jsx)(n.td,{children:"Visuelles Scrolling"}),(0,r.jsx)(n.td,{children:"Momentum + Bounce-Effekt"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Zuk\xfcnftige Erweiterungen:"}),"\nLong Press k\xf6nnte f\xfcr Item-Details oder Kontext-Men\xfcs interessant sein, ist aber nicht im aktuellen Scope."]}),"\n",(0,r.jsx)(n.h2,{id:"planung-sensoren-und-aktoren",children:"Planung Sensoren und Aktoren"}),"\n",(0,r.jsx)(n.h3,{id:"\xfcbersicht-geplanter-sensoren-und-aktoren",children:"\xdcbersicht geplanter Sensoren und Aktoren"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Sensoren"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Sensor"}),(0,r.jsx)(n.th,{children:"Verwendungszweck"}),(0,r.jsx)(n.th,{children:"Einsatzort"}),(0,r.jsx)(n.th,{children:"Ausl\xf6ser"}),(0,r.jsx)(n.th,{children:"Technologie"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Accelerometer"})}),(0,r.jsx)(n.td,{children:"Shake-to-Undo Funktion"}),(0,r.jsx)(n.td,{children:"Game Screen"}),(0,r.jsx)(n.td,{children:"Ger\xe4t sch\xfctteln (>1.5G)"}),(0,r.jsx)(n.td,{children:"expo-sensors"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Camera"})}),(0,r.jsx)(n.td,{children:"Profilbild aufnehmen"}),(0,r.jsx)(n.td,{children:"Settings Screen"}),(0,r.jsx)(n.td,{children:"Button-Press"}),(0,r.jsx)(n.td,{children:"expo-camera"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Aktoren"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Aktor"}),(0,r.jsx)(n.th,{children:"Verwendungszweck"}),(0,r.jsx)(n.th,{children:"Einsatzort"}),(0,r.jsx)(n.th,{children:"Ausl\xf6ser"}),(0,r.jsx)(n.th,{children:"Pattern"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Haptic Engine"})}),(0,r.jsx)(n.td,{children:"Taktiles Feedback"}),(0,r.jsx)(n.td,{children:"Alle Screens"}),(0,r.jsx)(n.td,{children:"Kauf, Fehler, Tab Wechsel"}),(0,r.jsx)(n.td,{children:"Light/Medium/Success/Error"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Vibration"})}),(0,r.jsx)(n.td,{children:"Vibrationsmuster"}),(0,r.jsx)(n.td,{children:"Game Screen, Settings"}),(0,r.jsx)(n.td,{children:"Kauf, Undo, Game Complete"}),(0,r.jsx)(n.td,{children:"50-500ms Pattern"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"begr\xfcndung-der-wahl",children:"Begr\xfcndung der Wahl"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Accelerometer:"})," Der Beschleunigungssensor erm\xf6glicht eine nat\xfcrliche Undo-Geste durch Sch\xfctteln. Das ist intuitiver als ein Button und nutzt die physische Bewegung des Smartphones. Mit einem Schwellenwert von 1.5G und 1-Sekunden-Cooldown werden Fehlausl\xf6sungen verhindert."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Camera:"})," Die Kamera erm\xf6glicht Personalisierung durch ein Profilbild in den Settings. User k\xf6nnen ein Foto mit Front- oder Back-Kamera aufnehmen, das lokal gespeichert wird."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Haptic Engine:"}),' Haptisches Feedback ist subtiler und energieeffizienter als Vibration. Verschiedene Pattern (Light, Medium, Heavy) f\xfcr unterschiedliche Aktionen machen die App "f\xfchlbar" und verbessern die User Experience erheblich.']}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Vibration:"}),' St\xe4rkeres Feedback f\xfcr wichtige Events. Pattern-Vibration erm\xf6glicht rhythmische Sequenzen wie ein "Sieges-Pattern" beim Spielende und ist universell auf allen Ger\xe4ten verf\xfcgbar.']}),"\n",(0,r.jsx)(n.h3,{id:"interaktions-szenarien",children:"Interaktions-Szenarien"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Erfolgreicher Kauf:"}),' User tippt "Buy Item", System pr\xfcft Budget, bei Erfolg folgt Haptic Medium und Vibration 100ms.']}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Fehler (zu wenig Geld):"}),' User tippt "Buy Item", Budget reicht nicht, es folgt Haptic Error und Doppel-Vibration (100-50-100ms).']}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Shake-to-Undo:"})," User sch\xfcttelt Ger\xe4t, Accelerometer erkennt >1.5G, letztes Item wird zur\xfcckverkauft, Haptic Success, Vibration 50ms und Alert erscheinen."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Profilbild aufnehmen:"}),' User tippt "Take Photo" in Settings, System fordert bei Bedarf Camera-Permission an, Kamera \xf6ffnet sich, nach Capture wird Foto-URI gespeichert und als Vorschau angezeigt.']}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Game Complete:"})," Budget erreicht 0, es folgt Haptic Success und rhythmisches Vibrationsmuster (200-100-200-100-200-100-500ms)."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tab-Navigation:"})," User wechselt Tab, es folgt subtiles Haptic Light Feedback."]}),"\n",(0,r.jsx)(n.h3,{id:"technische-integration-planung",children:"Technische Integration (Planung)"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Sensor-Module:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Accelerometer via Expo Sensors API (10 Hz Update-Rate)"}),"\n",(0,r.jsx)(n.li,{children:"Kamera via Expo Camera API (Permission-basiert)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Aktor-Module:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Haptic Engine via Expo Haptics API"}),"\n",(0,r.jsx)(n.li,{children:"Vibration via React Native Vibration API"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Architektur-Planung:"}),"\nDie Sensor- und Aktor-Logik wird in den ViewModels abstrahiert:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Camera-Logik im SettingsViewModel"}),"\n",(0,r.jsx)(n.li,{children:"Accelerometer-Logik im GameViewModel"}),"\n",(0,r.jsx)(n.li,{children:"Haptics und Vibration als wiederverwendbare Utility-Functions"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Dies erm\xf6glicht saubere Trennung zwischen UI und Logik sowie einfaches Testing."}),"\n",(0,r.jsx)(n.h2,{id:"erkl\xe4rung-des-artefakts",children:"Erkl\xe4rung des Artefakts"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Architektur und Technologie"})}),"\n",(0,r.jsx)(n.p,{children:"Ich entwickle die App mit React Native und Expo, weil ich damit beide Plattformen \u2013 iOS und Android mit einem einzigen Code bedienen kann. Das spart viel Zeit und ich muss nicht zwei verschiedene Apps separat programmieren. Expo bietet au\xdferdem fertige Module f\xfcr Sensoren und haptisches Feedback, was die Entwicklung deutlich vereinfacht. Die Expo Go App erm\xf6glicht mir, die App w\xe4hrend der Entwicklung direkt auf meinem Smartphone zu testen, ohne sie jedes Mal komplett neu installieren zu m\xfcssen."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Datenspeicherung"})}),"\n",(0,r.jsx)(n.p,{children:"F\xfcr die Speicherung nutze ich AsyncStorage, eine einfache lokale Datenbank. Ich speichere zwei Arten von Daten: den aktuellen Spielstand mit Budget, gekauften Items und Spielzeit, sowie langfristige Statistiken wie gespielte Spiele und Lieblingskategorien. Nach jedem Kauf wird automatisch gespeichert, sodass nichts verloren geht, wenn die App geschlossen wird. Die Daten bleiben komplett auf dem Ger\xe4t und funktionieren ohne Internet."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Gesten und Interaktion"})}),"\n",(0,r.jsx)(n.p,{children:'Die Bedienung basiert auf drei Gesten: Tippen zum Kaufen, Scrollen durch die Item-Liste und Sch\xfctteln zum R\xfcckg\xe4ngigmachen. Besonders die Shake-Funktion ist interessant, der Beschleunigungssensor misst die Bewegung des Ger\xe4ts, und wenn die Beschleunigung einen Schwellenwert \xfcberschreitet, wird der letzte Kauf r\xfcckg\xe4ngig gemacht. Damit habe ich eine "Undo" Funktion ohne zus\xe4tzlichen Button.'}),"\n",(0,r.jsx)(n.h2,{id:"kritische-beurteilung",children:"Kritische Beurteilung"}),"\n",(0,r.jsx)(n.h3,{id:"the-good",children:"The good"}),"\n",(0,r.jsx)(n.p,{children:"Die geplante Architektur folgt dem MVVM-Pattern mit klarer Trennung zwischen Ansicht, Logik und Daten. Die Komponenten sind als wiederverwendbar konzipiert und sauber strukturiert. Die Datenspeicherung ist durchdacht mit automatischem Speichern nach jeder Aktion, wodurch kein Fortschritt verloren geht. Die JSON-Struktur l\xe4sst sich leicht erweitern. Die Gestiksteuerung ist intuitiv geplant \u2013 besonders die Shake-to-Undo-Funktion mit eingebautem Cooldown (1000ms) soll versehentliche Mehrfach-Aktionen verhindern. Das haptische Feedback ist differenziert je nach Aktion geplant und soll die User Experience verbessern."}),"\n",(0,r.jsx)(n.h3,{id:"the-bad",children:"The bad"}),"\n",(0,r.jsx)(n.p,{children:"Es sind nur grundlegende Gesten geplant \u2013 Swipe-Gesten zum Verkaufen oder Long-Press f\xfcr Item-Details w\xfcrden die Interaktion noch intuitiver machen, sind aber nicht im Scope. Die Speicherung ist nur lokal ohne Cloud-Synchronisation geplant. Wenn jemand die App deinstalliert oder das Ger\xe4t wechselt, sind alle Daten weg. Der Accelerometer l\xe4uft nur w\xe4hrend die MainGameView aktiv ist, aber mit 10 Hz Update-Rate (100ms Intervall) k\xf6nnte dies die Batterie belasten. Die Kamera-Funktion ist auf Foto-Aufnahme beschr\xe4nkt \u2013 Video, Filter oder erweiterte Kamera-Features sind nicht geplant."}),"\n",(0,r.jsx)(n.h2,{id:"fazit",children:"Fazit"}),"\n",(0,r.jsx)(n.p,{children:"Die Planung erf\xfcllt alle Grundanforderungen von HZ2:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Applikationstyp begr\xfcndet gew\xe4hlt (React Native/Expo f\xfcr Cross-Platform)"}),"\n",(0,r.jsx)(n.li,{children:"Datenspeicherung funktional geplant (AsyncStorage mit Auto-Save)"}),"\n",(0,r.jsx)(n.li,{children:"Gestiksteuerung konzipiert (Shake-to-Undo mit Accelerometer)"}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"2 Sensoren geplant:"})," Accelerometer (Shake) + Camera (Profilbild)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"2 Aktoren geplant:"})," Haptic Engine (Feedback) + Vibration (Pattern)"]}),"\n",(0,r.jsx)(n.li,{children:"Sensor-Aktor-Mapping klar definiert mit 6 Interaktions-Szenarien"}),"\n",(0,r.jsx)(n.li,{children:"Architektur solide und erweiterbar (MVVM-Pattern)"}),"\n"]})]})}function o(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>d});var t=i(6540);const r={},s=t.createContext(r);function l(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);