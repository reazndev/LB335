"use strict";(globalThis.webpackChunkdocumentation=globalThis.webpackChunkdocumentation||[]).push([[842],{2778:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/1.drawio-a1b5b06d04e934c782164d69f26d87db.png"},2988:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/shake-flow.drawio-adc9e4f2b9f8bd4ee612f3fe12235d48.png"},3096:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/Screenshot-shake-93ed7cdd82c057064d6513383953a55d.png"},3099:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/2.drawio-171772ef07505416c417a757bb0930e8.png"},3264:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/3.drawio-ed80fd003d0ef5bbb79f09ed13e06115.png"},3472:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/datenfluss.drawio-9749c8fbf189c6da932a5dd3c44d58b4.png"},4628:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/folder-structure1-f8cd0c5b7e5f197ee86e50803052a00c.png"},5949:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/Screenshot-home-e016bffc4d6c6520045cb1977da4e5e1.png"},6113:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/Screenshot-pop-up-17f7674ab549b5bf81a4214863a54dd3.png"},6576:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/navigation-flow.drawio-c995126bfe351369df89f9b4c78842f7.png"},7087:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/folder-structure2-c7f93944ec9cd293842227f3ec88f11b.png"},7211:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/tab-wechsel-flow-e125aafb17253efbbe6e4af232e55d0f.png"},7523:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/Screenshot-cant-afford-2720057b288828b82b2248daf729d4d7.png"},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}},9173:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/Screenshot-ending-fde0549577a39cf29b538c6f5a8ae39e.png"},9231:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"lb335/hz3-implementation","title":"HZ3 - Implementation","description":"Implementierung der mobilen Applikation mit MVVM, Navigation und Sensoren","source":"@site/docs/lb335/hz3-implementation.md","sourceDirName":"lb335","slug":"/lb335/hz3-implementation","permalink":"/LB335/docs/lb335/hz3-implementation","draft":false,"unlisted":false,"editUrl":"https://github.com/reazndev/lb335/docs/lb335/hz3-implementation.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"HZ3 - Implementation","description":"Implementierung der mobilen Applikation mit MVVM, Navigation und Sensoren"},"sidebar":"tutorialSidebar","previous":{"title":"HZ2 - Planung und Architektur","permalink":"/LB335/docs/lb335/hz2-architecture"},"next":{"title":"HZ4 - Store Deployment","permalink":"/LB335/docs/lb335/hz4-deployment"}}');var s=t(4848),r=t(8453);const a={sidebar_position:3,title:"HZ3 - Implementation",description:"Implementierung der mobilen Applikation mit MVVM, Navigation und Sensoren"},l="Handlungsziel 3: Implementierung der mobilen Applikation",c={},o=[{value:"Projektstruktur",id:"projektstruktur",level:2},{value:"Projekt Demo",id:"projekt-demo",level:3},{value:"Nachweis der Zielerreichung",id:"nachweis-der-zielerreichung",level:2},{value:"1. MVVM-Architektur Umsetzung",id:"1-mvvm-architektur-umsetzung",level:3},{value:"Model Layer (Datenmodelle)",id:"model-layer-datenmodelle",level:4},{value:"ViewModel Layer (Business Logic)",id:"viewmodel-layer-business-logic",level:4},{value:"View Layer (UI Components)",id:"view-layer-ui-components",level:4},{value:"2. Navigation-Implementierung",id:"2-navigation-implementierung",level:3},{value:"Navigations-Architektur",id:"navigations-architektur",level:4},{value:"Root Layout (Stack Navigator)",id:"root-layout-stack-navigator",level:4},{value:"Tab Navigation mit Shared ViewModels",id:"tab-navigation-mit-shared-viewmodels",level:4},{value:"Screen-Implementierung",id:"screen-implementierung",level:4},{value:"Custom Haptic Tab Button",id:"custom-haptic-tab-button",level:4},{value:"File-Based Routing Mapping",id:"file-based-routing-mapping",level:4},{value:"Navigation Flow Diagram",id:"navigation-flow-diagram",level:4},{value:"Vorteile der Navigation-Architektur",id:"vorteile-der-navigation-architektur",level:4},{value:"3. Gestiksteuerung Umsetzung",id:"3-gestiksteuerung-umsetzung",level:3},{value:"Touch-Gesten",id:"touch-gesten",level:4},{value:"Shake to Undo",id:"shake-to-undo",level:4},{value:"Weitere Gesten",id:"weitere-gesten",level:4},{value:"4. Sensor/Aktor Integration",id:"4-sensoraktor-integration",level:3},{value:"Accelerometer (Sensor)",id:"accelerometer-sensor",level:4},{value:"Camera (Sensor)",id:"camera-sensor",level:4},{value:"Haptic Engine (Aktor)",id:"haptic-engine-aktor",level:4},{value:"Vibration (Aktor)",id:"vibration-aktor",level:4},{value:"5. Persistente Datenspeicherung",id:"5-persistente-datenspeicherung",level:3},{value:"Speichern",id:"speichern",level:4},{value:"Laden",id:"laden",level:4},{value:"Gespeicherte Daten",id:"gespeicherte-daten",level:4},{value:"Auto-Save",id:"auto-save",level:4},{value:"Beispiel-Flow",id:"beispiel-flow",level:4},{value:"Daten zur\xfccksetzen",id:"daten-zur\xfccksetzen",level:4},{value:"Kritische Beurteilung",id:"kritische-beurteilung",level:2},{value:"The good",id:"the-good",level:3},{value:"The bad",id:"the-bad",level:3},{value:"Fazit",id:"fazit",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"handlungsziel-3-implementierung-der-mobilen-applikation",children:"Handlungsziel 3: Implementierung der mobilen Applikation"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"MVVM-Architektur Implementierung"}),"\n",(0,s.jsx)(n.li,{children:"Navigation mit Expo Router"}),"\n",(0,s.jsx)(n.li,{children:"Gestiksteuerung Umsetzung"}),"\n",(0,s.jsx)(n.li,{children:"Sensor und Aktor Integration"}),"\n",(0,s.jsx)(n.li,{children:"Persistente Datenspeicherung"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"projektstruktur",children:"Projektstruktur"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Folder Structure",src:t(4628).A+"",width:"303",height:"511"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Folder Structure",src:t(7087).A+"",width:"221",height:"301"})}),"\n",(0,s.jsx)(n.h3,{id:"projekt-demo",children:"Projekt Demo"}),"\n",(0,s.jsxs)("video",{controls:!0,width:"100%",style:{maxWidth:"800px"},children:[(0,s.jsx)("source",{src:"/img/screen-20251027-083621-compressed.mp4",type:"video/mp4"}),(0,s.jsx)(n.p,{children:"Your browser does not support the video tag."})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"Screenshot",src:t(5949).A+"",width:"1080",height:"2424"}),"\n",(0,s.jsx)(n.img,{alt:"Screenshot",src:t(9507).A+"",width:"1080",height:"2424"}),"\n",(0,s.jsx)(n.img,{alt:"Screenshot",src:t(9343).A+"",width:"1080",height:"2424"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Screenshot",src:t(3096).A+"",width:"1080",height:"2424"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{alt:"Screenshot",src:t(7523).A+"",width:"1080",height:"2424"}),"\n",(0,s.jsx)(n.img,{alt:"Screenshot",src:t(9173).A+"",width:"1080",height:"2424"}),"\n",(0,s.jsx)(n.img,{alt:"Screenshot",src:t(6113).A+"",width:"1080",height:"2424"})]}),"\n",(0,s.jsx)(n.h2,{id:"nachweis-der-zielerreichung",children:"Nachweis der Zielerreichung"}),"\n",(0,s.jsx)(n.h3,{id:"1-mvvm-architektur-umsetzung",children:"1. MVVM-Architektur Umsetzung"}),"\n",(0,s.jsx)(n.p,{children:"Die App folgt dem MVVM-Pattern mit drei klar getrennten Schichten. Models definieren die Datenstrukturen, ViewModels enthalten die Business-Logik, und Views sind nur f\xfcr die Darstellung zust\xe4ndig."}),"\n",(0,s.jsx)(n.h4,{id:"model-layer-datenmodelle",children:"Model Layer (Datenmodelle)"}),"\n",(0,s.jsx)(n.p,{children:"Die Models sind reine TypeScript-Interfaces ohne Logik - sie definieren nur die Form der Daten:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/models/index.ts\n\nexport interface ViewModelBase {\n  subscribe(callback: () => void): () => void;\n  notifyChange(): void;\n}\n\nexport interface PurchaseItem {\n  id: string;\n  name: string;\n  price: number;\n  description: string;\n  category: string;\n}\n\nexport interface GameState {\n  currentBudget: number;\n  purchasedItems: PurchaseItem[];\n  totalSpent: number;\n  gameCompleted: boolean;\n  startTime: Date;\n  endTime?: Date;\n}\n\nexport interface Statistics {\n  gamesPlayed: number;\n  fastestCompletion?: number;\n  averageItemsPerGame: number;\n  favoriteCategory?: string;\n  totalMoneySpent: number;\n  mostExpensiveItem?: PurchaseItem;\n  totalItemsPurchased: number;\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"viewmodel-layer-business-logic",children:"ViewModel Layer (Business Logic)"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"BaseViewModel:"})}),"\n",(0,s.jsx)(n.p,{children:"Alle ViewModels erben von dieser Basis-Klasse, die das Observer Pattern implementiert. Views k\xf6nnen sich subscriben und werden automatisch \xfcber \xc4nderungen informiert:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/viewmodels/BaseViewModel.ts\n\nexport abstract class BaseViewModel implements ViewModelBase {\n  private subscribers: (() => void)[] = [];\n  \n  subscribe(callback: () => void): () => void {\n    this.subscribers.push(callback);\n    \n    return () => {\n      const index = this.subscribers.indexOf(callback);\n      if (index > -1) {\n        this.subscribers.splice(index, 1);\n      }\n    };\n  }\n\n  notifyChange(): void {\n    this.subscribers.forEach(callback => callback());\n  }\n\n  dispose(): void {\n    this.subscribers = [];\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"GameViewModel:"})}),"\n",(0,s.jsx)(n.p,{children:"Das GameViewModel enth\xe4lt die gesamte Spiellogik. Hier ein Beispiel f\xfcr die purchaseItem-Methode:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/viewmodels/GameViewModel.ts\n\nexport class GameViewModel extends BaseViewModel {\n  private gameState: GameState;\n  private statistics: Statistics;\n\n  getGameState(): GameState {\n    return { ...this.gameState };  // Defensive Copy\n  }\n\n  purchaseItem(item: PurchaseItem): boolean {\n    if (this.gameState.currentBudget >= item.price) {\n      // Budget abziehen\n      this.gameState.currentBudget -= item.price;\n      this.gameState.totalSpent += item.price;\n      this.gameState.purchasedItems.push({ ...item });\n\n      // Statistiken aktualisieren\n      this.updateStatisticsOnPurchase(item);\n\n      // Spiel abgeschlossen?\n      if (this.gameState.currentBudget === 0) {\n        this.gameState.gameCompleted = true;\n        this.gameState.endTime = new Date();\n        this.updateStatisticsOnCompletion();\n      }\n\n      // Speichern und Views benachrichtigen\n      this.saveGameState();\n      this.notifyChange();\n      return true;\n    }\n    return false;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Die Methode pr\xfcft zuerst ob genug Budget vorhanden ist, aktualisiert dann den State, speichert automatisch und benachrichtigt alle Views \xfcber die \xc4nderung."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Weitere ViewModels:"})}),"\n",(0,s.jsx)(n.p,{children:"Das SettingsViewModel und StatsViewModel funktionieren nach dem gleichen Prinzip:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/viewmodels/SettingsViewModel.ts\nexport class SettingsViewModel extends BaseViewModel {\n  private settings: AppSettings = { ...defaultSettings };\n\n  async setVibrationEnabled(enabled: boolean): Promise<void> {\n    this.settings.vibrationEnabled = enabled;\n    await this.saveSettings();\n    this.notifyChange();\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"view-layer-ui-components",children:"View Layer (UI Components)"}),"\n",(0,s.jsx)(n.p,{children:"Views erhalten ViewModels als Props und subscriben sich zu deren \xc4nderungen:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/views/MainGameView.tsx\n\ninterface MainGameViewProps {\n  viewModel: GameViewModel;\n}\n\nexport function MainGameView({ viewModel }: MainGameViewProps) {\n  const [gameState, setGameState] = useState<GameState>(\n    viewModel.getGameState()\n  );\n  \n  // Subscribe zu ViewModel-\xc4nderungen\n  useEffect(() => {\n    const unsubscribe = viewModel.subscribe(() => {\n      setGameState(viewModel.getGameState());\n    });\n    return unsubscribe;\n  }, [viewModel]);\n\n  const handlePurchase = useCallback(async (item: PurchaseItem) => {\n    if (viewModel.purchaseItem(item)) {\n      await hapticPatterns.purchase();\n    }\n  }, [viewModel]);\n\n  return (\n    <ThemedView style={styles.container}>\n      <ThemedText>{formatCurrency(gameState.currentBudget)}</ThemedText>\n      <FlatList\n        data={allItems}\n        renderItem={({ item }) => (\n          <ThemedView onTouchEnd={() => handlePurchase(item)}>\n            {/* Item UI */}\n          </ThemedView>\n        )}\n      />\n    </ThemedView>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Datenfluss:"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Datenfluss",src:t(3472).A+"",width:"276",height:"561"})}),"\n",(0,s.jsx)(n.h3,{id:"2-navigation-implementierung",children:"2. Navigation-Implementierung"}),"\n",(0,s.jsx)(n.p,{children:"Die App nutzt Expo Router mit file-based navigation - die Ordnerstruktur definiert automatisch die Routes. Das ist wartbarer und typsicherer als programmatisches Routing."}),"\n",(0,s.jsx)(n.h4,{id:"navigations-architektur",children:"Navigations-Architektur"}),"\n",(0,s.jsxs)(n.p,{children:["Die App hat eine ",(0,s.jsx)(n.strong,{children:"hierarchische Navigationsstruktur"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Root Layout (Stack Navigator)\n    \u251c\u2500\u2500 (tabs) - Tab Navigator [HIDDEN HEADER]\n    \u2502   \u251c\u2500\u2500 index.tsx (Game Screen)\n    \u2502   \u251c\u2500\u2500 statistics.tsx (Statistics Screen)\n    \u2502   \u2514\u2500\u2500 settings.tsx (Settings Screen)\n    \u2514\u2500\u2500 modal.tsx - Modal Screen\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Folder Structure",src:t(7087).A+"",width:"221",height:"301"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Tab Navigator [HIDDEN HEADER]"}),"\n",(0,s.jsx)(n.li,{children:"index.tsx (Game Screen)"}),"\n",(0,s.jsx)(n.li,{children:"statistics.tsx (Statistics Screen)"}),"\n",(0,s.jsx)(n.li,{children:"settings.tsx (Settings Screen)"}),"\n",(0,s.jsx)(n.li,{children:"modal.tsx - Modal Screen"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Warum dieser Aufbau?"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stack Navigator"})," als Root erm\xf6glicht Modals \xfcber den Tabs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"(tabs) Route-Gruppe"})," versteckt den Namen aus der URL"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Tab Navigator"})," erm\xf6glicht schnellen Wechsel zwischen Hauptscreens"]}),"\n",(0,s.jsx)(n.li,{children:"Shared ViewModels \xfcber Context = kein Props-Drilling"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"root-layout-stack-navigator",children:"Root Layout (Stack Navigator)"}),"\n",(0,s.jsx)(n.p,{children:"Der Root-Layout definiert den grundlegenden Navigations-Container und das Theming:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// app/_layout.tsx\n\nimport { DarkTheme, DefaultTheme, ThemeProvider } from '@react-navigation/native';\nimport { Stack } from 'expo-router';\nimport { StatusBar } from 'expo-status-bar';\nimport { useColorScheme } from '@/hooks/use-color-scheme';\n\nexport const unstable_settings = {\n  anchor: '(tabs)',  // Startpunkt der App\n};\n\nexport default function RootLayout() {\n  const colorScheme = useColorScheme();\n\n  return (\n    <ThemeProvider value={colorScheme === 'dark' ? DarkTheme : DefaultTheme}>\n      <Stack>\n        {/* Tab Navigator als Hauptnavigation */}\n        <Stack.Screen name=\"(tabs)\" options={{ headerShown: false }} />\n        \n        {/* Modal Screen f\xfcr zuk\xfcnftige Features */}\n        <Stack.Screen \n          name=\"modal\" \n          options={{ \n            presentation: 'modal', \n            title: 'Modal' \n          }} \n        />\n      </Stack>\n      <StatusBar style=\"auto\" />\n    </ThemeProvider>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Features:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stack Navigator"}),": Erm\xf6glicht Modal-Screens \xfcber den Tabs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"headerShown: false"}),": Tabs brauchen keinen Header"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"unstable_settings.anchor"}),": Definiert die Start-Route"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"tab-navigation-mit-shared-viewmodels",children:"Tab Navigation mit Shared ViewModels"}),"\n",(0,s.jsx)(n.p,{children:"Die Tab-Navigation ist der Core der App. Hier werden die ViewModels zentral erstellt und \xfcber Context geteilt:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// app/(tabs)/_layout.tsx\n\nimport MaterialIcons from '@expo/vector-icons/MaterialIcons';\nimport { Tabs } from 'expo-router';\nimport React, { createContext, useContext, useState } from 'react';\nimport { GestureHandlerRootView } from 'react-native-gesture-handler';\n\nimport { HapticTab } from '@/components/haptic-tab';\nimport { Colors } from '@/constants/theme';\nimport { useColorScheme } from '@/hooks/use-color-scheme';\nimport { GameViewModel, SettingsViewModel, StatsViewModel } from '@/src/viewmodels';\n\n// Context f\xfcr Shared ViewModels\nconst ViewModelsContext = createContext<{\n  gameViewModel: GameViewModel;\n  settingsViewModel: SettingsViewModel;\n  statsViewModel: StatsViewModel;\n} | null>(null);\n\n// Custom Hook f\xfcr typsicheren Zugriff\nexport const useViewModels = () => {\n  const context = useContext(ViewModelsContext);\n  if (!context) {\n    throw new Error('useViewModels must be used within a ViewModelsProvider');\n  }\n  return context;\n};\n\nexport default function TabLayout() {\n  const colorScheme = useColorScheme();\n\n  // ViewModels werden EINMAL erstellt und geteilt\n  const [gameViewModel] = useState(() => new GameViewModel());\n  const [settingsViewModel] = useState(() => new SettingsViewModel());\n  const [statsViewModel] = useState(() => new StatsViewModel());\n\n  const viewModels = {\n    gameViewModel,\n    settingsViewModel,\n    statsViewModel,\n  };\n\n  return (\n    <ViewModelsContext.Provider value={viewModels}>\n      <GestureHandlerRootView style={{ flex: 1 }}>\n        <Tabs\n          screenOptions={{\n            tabBarActiveTintColor: Colors[colorScheme ?? 'light'].tint,\n            headerShown: false,\n            tabBarButton: HapticTab,  // Custom Button mit Haptic Feedback\n          }}>\n          <Tabs.Screen\n            name=\"index\"\n            options={{\n              title: 'Game',\n              tabBarIcon: ({ color }) => (\n                <MaterialIcons size={28} name=\"gamepad\" color={color} />\n              ),\n            }}\n          />\n          <Tabs.Screen\n            name=\"statistics\"\n            options={{\n              title: 'Statistics',\n              tabBarIcon: ({ color }) => (\n                <MaterialIcons size={28} name=\"bar-chart\" color={color} />\n              ),\n            }}\n          />\n          <Tabs.Screen\n            name=\"settings\"\n            options={{\n              title: 'Settings',\n              tabBarIcon: ({ color }) => (\n                <MaterialIcons size={28} name=\"settings\" color={color} />\n              ),\n            }}\n          />\n        </Tabs>\n      </GestureHandlerRootView>\n    </ViewModelsContext.Provider>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Warum dieser Ansatz?"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Single Source of Truth"}),": ViewModels werden nur einmal erstellt"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Shared State"}),": Alle Tabs arbeiten mit den gleichen Daten"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic Updates"}),": \xc4nderungen in einem Tab sind sofort in allen sichtbar"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Safety"}),": TypeScript pr\xfcft die Context-Nutzung zur Compile-Zeit"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Kein Props-Drilling"}),": Direkte Injection \xfcber Custom Hook"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Beispiel-Flow:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"User kauft Item im Game Tab"}),"\n",(0,s.jsx)(n.li,{children:"GameViewModel.purchaseItem() wird aufgerufen"}),"\n",(0,s.jsx)(n.li,{children:"GameState wird aktualisiert"}),"\n",(0,s.jsx)(n.li,{children:"notifyChange() benachrichtigt alle Subscriber"}),"\n",(0,s.jsx)(n.li,{children:"Statistics Tab zeigt neue Werte (wenn aktiv)"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"screen-implementierung",children:"Screen-Implementierung"}),"\n",(0,s.jsx)(n.p,{children:"Die Screens sind Container die nur ViewModels aus dem Context holen und an Views weiterreichen:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Game Screen:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// app/(tabs)/index.tsx\n\nimport { MainGameView } from '@/src/views';\nimport { useViewModels } from './_layout';\n\nexport default function GameScreen() {\n  // Get shared ViewModel from context\n  const { gameViewModel } = useViewModels();\n\n  // MVVM: Pass shared ViewModel to View component\n  return <MainGameView viewModel={gameViewModel} />;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Statistics Screen:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// app/(tabs)/statistics.tsx\n\nimport { StatisticsView } from '@/src/views';\nimport { useViewModels } from './_layout';\n\nexport default function StatisticsScreen() {\n  // Get shared ViewModel from context\n  const { gameViewModel } = useViewModels();\n\n  // MVVM: Pass shared ViewModel to View component\n  return <StatisticsView viewModel={gameViewModel} />;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Settings Screen:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// app/(tabs)/settings.tsx\n\nimport { SettingsView } from '@/src/views';\nimport { useViewModels } from './_layout';\n\nexport default function SettingsScreen() {\n  // Settings braucht alle drei ViewModels\n  const { gameViewModel, settingsViewModel, statsViewModel } = useViewModels();\n\n  return (\n    <SettingsView\n      settingsViewModel={settingsViewModel}\n      gameViewModel={gameViewModel}\n      statsViewModel={statsViewModel}\n    />\n  );\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Design Pattern:"})}),"\n",(0,s.jsx)(n.p,{children:"Screens sind Composition Root - sie komponieren die App aus ViewModels und Views. Keine Business-Logik, nur Wiring."}),"\n",(0,s.jsx)(n.h4,{id:"custom-haptic-tab-button",children:"Custom Haptic Tab Button"}),"\n",(0,s.jsx)(n.p,{children:"Jeder Tab-Wechsel gibt haptisches Feedback f\xfcr bessere UX:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// components/haptic-tab.tsx\n\nimport { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';\nimport { PlatformPressable } from '@react-navigation/elements';\nimport * as Haptics from 'expo-haptics';\n\nexport function HapticTab(props: BottomTabBarButtonProps) {\n  return (\n    <PlatformPressable\n      {...props}\n      onPressIn={(ev) => {\n        // Nur auf iOS (Android hat System-Haptics)\n        if (process.env.EXPO_OS === 'ios') {\n          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n        }\n        props.onPressIn?.(ev);\n      }}\n    />\n  );\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Warum PlatformPressable?"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Cross-Platform Support (iOS/Android)"}),"\n",(0,s.jsx)(n.li,{children:"Native Ripple Effekt auf Android"}),"\n",(0,s.jsx)(n.li,{children:"Accessibility Features out of the box"}),"\n",(0,s.jsx)(n.li,{children:"Performance optimiert f\xfcr Touch"}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"file-based-routing-mapping",children:"File-Based Routing Mapping"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"URL zu Datei-Mapping:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"URL"}),(0,s.jsx)(n.th,{children:"Datei"}),(0,s.jsx)(n.th,{children:"Screen"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"/"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"app/(tabs)/index.tsx"})}),(0,s.jsx)(n.td,{children:"Game Screen"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"/statistics"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"app/(tabs)/statistics.tsx"})}),(0,s.jsx)(n.td,{children:"Statistics Screen"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"/settings"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"app/(tabs)/settings.tsx"})}),(0,s.jsx)(n.td,{children:"Settings Screen"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"/modal"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"app/modal.tsx"})}),(0,s.jsx)(n.td,{children:"Modal Screen"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Die ",(0,s.jsx)(n.strong,{children:"(tabs)"})," Route-Gruppe ist unsichtbar in der URL - macht die URLs sauberer."]}),"\n",(0,s.jsx)(n.h4,{id:"navigation-flow-diagram",children:"Navigation Flow Diagram"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Navigation Flow",src:t(6576).A+"",width:"276",height:"861"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Tab-Wechsel Flow:"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Navigation Flow",src:t(7211).A+"",width:"276",height:"561"})}),"\n",(0,s.jsx)(n.h4,{id:"vorteile-der-navigation-architektur",children:"Vorteile der Navigation-Architektur"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"File-Based Routing:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Routes sind durch Ordnerstruktur sofort ersichtlich"}),"\n",(0,s.jsx)(n.li,{children:"TypeScript kann Routes validieren"}),"\n",(0,s.jsx)(n.li,{children:"Kein manuelles Route-Registrieren n\xf6tig"}),"\n",(0,s.jsx)(n.li,{children:"Deep-Links funktionieren automatisch"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Shared Context f\xfcr ViewModels:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Single Source of Truth f\xfcr App-State"}),"\n",(0,s.jsx)(n.li,{children:"Keine Props durch mehrere Ebenen"}),"\n",(0,s.jsx)(n.li,{children:"Automatische Updates \xfcber alle Screens"}),"\n",(0,s.jsx)(n.li,{children:"Performance: ViewModels werden nicht neu erstellt"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Tab Navigation:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Schneller Zugriff auf Hauptfunktionen"}),"\n",(0,s.jsx)(n.li,{children:"Native Look & Feel (iOS/Android)"}),"\n",(0,s.jsx)(n.li,{children:"Haptic Feedback f\xfcr bessere UX"}),"\n",(0,s.jsx)(n.li,{children:"Icons verdeutlichen Funktionen"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-gestiksteuerung-umsetzung",children:"3. Gestiksteuerung Umsetzung"}),"\n",(0,s.jsx)(n.h4,{id:"touch-gesten",children:"Touch-Gesten"}),"\n",(0,s.jsx)(n.p,{children:"Kaufen funktioniert \xfcber einfache Touch Events:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/views/MainGameView.tsx\n\nconst renderItem = ({ item }: { item: PurchaseItem }) => {\n  const canAfford = gameState.currentBudget >= item.price;\n  \n  return (\n    <ThemedView style={styles.itemCard}>\n      <ThemedText>{item.name}</ThemedText>\n      <ThemedText>{formatCurrency(item.price)}</ThemedText>\n      \n      <ThemedView\n        style={[\n          styles.purchaseButton,\n          !canAfford && styles.disabledButton\n        ]}\n        onTouchEnd={() => handlePurchase(item)}\n      >\n        <ThemedText style={styles.purchaseButtonText}>Buy Item</ThemedText>\n      </ThemedView>\n    </ThemedView>\n  );\n};\n\nconst handlePurchase = useCallback(async (item: PurchaseItem) => {\n  if (viewModel.purchaseItem(item)) {\n    await hapticPatterns.purchase();\n    \n    if (viewModel.isGameCompleted()) {\n      await hapticPatterns.gameComplete();\n    }\n  } else {\n    await hapticPatterns.error();\n    showStyledAlert('Cannot afford this item', 'You don\\'t have enough money.');\n  }\n}, [viewModel, showStyledAlert]);\n"})}),"\n",(0,s.jsx)(n.h4,{id:"shake-to-undo",children:"Shake to Undo"}),"\n",(0,s.jsxs)(n.p,{children:["Funktion im Vieo gezeigt.\nDanach bekommt man diesen Bildschirm.\n",(0,s.jsx)(n.img,{alt:"Screenshot",src:t(3096).A+"",width:"1080",height:"2424"})]}),"\n",(0,s.jsx)(n.p,{children:"Ger\xe4t sch\xfctteln um den letzten Kauf r\xfcckg\xe4ngig zu machen."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/views/MainGameView.tsx\n\nuseEffect(() => {\n  let lastShakeTime = 0;\n  const SHAKE_THRESHOLD = 1.5;\n  const SHAKE_COOLDOWN = 1000;\n\n  Accelerometer.setUpdateInterval(100);\n  \n  const subscription = Accelerometer.addListener(({ x, y, z }) => {\n    // Magnitude berechnen\n    const acceleration = Math.sqrt(x * x + y * y + z * z);\n    const now = Date.now();\n    \n    if (acceleration > SHAKE_THRESHOLD && now - lastShakeTime > SHAKE_COOLDOWN) {\n      lastShakeTime = now;\n      handleShake();\n    }\n  });\n\n  return () => {\n    subscription.remove();\n  };\n}, [gameState.purchasedItems]);\n\nconst handleShake = async () => {\n  if (gameState.purchasedItems.length > 0) {\n    const lastItem = gameState.purchasedItems[gameState.purchasedItems.length - 1];\n    const success = viewModel.sellItem(lastItem);\n    \n    if (success) {\n      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n      Vibration.vibrate(50);\n      showStyledAlert(\n        'Undo Successful', \n        `Returned: ${lastItem.name} (+$${lastItem.price.toLocaleString()})`\n      );\n    }\n  }\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Wie funktioniert Shake-Detection?"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Accelerometer liefert x, y, z Werte (in G)"}),"\n",(0,s.jsxs)(n.li,{children:["Ich berechne die Magnitude: ",(0,s.jsx)(n.code,{children:"\u221a(x\xb2 + y\xb2 + z\xb2)"})]}),"\n",(0,s.jsx)(n.li,{children:"Wenn Magnitude > 1.5G -> Shake erkannt"}),"\n",(0,s.jsx)(n.li,{children:"Cooldown verhindert Doppel Trigger"}),"\n",(0,s.jsx)(n.li,{children:"Letztes Item wird zur\xfcckverkauft"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Normal liegt das Ger\xe4t bei etwa 1G (Erdanziehung). Beim Sch\xfctteln steigt die Beschleunigung deutlich an."}),"\n",(0,s.jsx)(n.h4,{id:"weitere-gesten",children:"Weitere Gesten"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Scrolling in der Item-Liste\n<FlatList\n  data={allItems}\n  renderItem={renderItem}\n  keyExtractor={(item) => item.id}\n  style={styles.itemsList}\n  showsVerticalScrollIndicator={true}\n  extraData={gameState.purchasedItems.length}\n/>\n\n// Pull-to-Refresh in Statistics\n<ScrollView \n  refreshControl={\n    <RefreshControl \n      refreshing={isRefreshing} \n      onRefresh={handleRefresh} \n    />\n  }\n>\n  {/* Content */}\n</ScrollView>\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Gesten-\xdcbersicht:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Geste"}),(0,s.jsx)(n.th,{children:"Wo"}),(0,s.jsx)(n.th,{children:"Was passiert"}),(0,s.jsx)(n.th,{children:"Feedback"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Tap"}),(0,s.jsx)(n.td,{children:"Purchase Button"}),(0,s.jsx)(n.td,{children:"Item kaufen"}),(0,s.jsx)(n.td,{children:"Haptic Medium + 100ms Vibration"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Shake"}),(0,s.jsx)(n.td,{children:"Game Screen"}),(0,s.jsx)(n.td,{children:"Letzter Kauf zur\xfcck"}),(0,s.jsx)(n.td,{children:"Haptic Success + 50ms Vibration"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Scroll"}),(0,s.jsx)(n.td,{children:"Item-Liste"}),(0,s.jsx)(n.td,{children:"Durchsuchen"}),(0,s.jsx)(n.td,{children:"Native Feedback"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Pull-to-Refresh"}),(0,s.jsx)(n.td,{children:"Statistics"}),(0,s.jsx)(n.td,{children:"Aktualisieren"}),(0,s.jsx)(n.td,{children:"Refresh Indicator"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Tab Press"}),(0,s.jsx)(n.td,{children:"Tab Bar"}),(0,s.jsx)(n.td,{children:"Navigation"}),(0,s.jsx)(n.td,{children:"Haptic Light"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"4-sensoraktor-integration",children:"4. Sensor/Aktor Integration"}),"\n",(0,s.jsx)(n.h4,{id:"accelerometer-sensor",children:"Accelerometer (Sensor)"}),"\n",(0,s.jsx)(n.p,{children:"Der Beschleunigungssensor misst die Bewegung des Ger\xe4ts in drei Achsen:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Accelerometer } from 'expo-sensors';\n\nAccelerometer.setUpdateInterval(100);  // 10 Hz\n\nconst subscription = Accelerometer.addListener(({ x, y, z }) => {\n  // x: Links/Rechts\n  // y: Oben/Unten  \n  // z: Vorne/Hinten\n  \n  const acceleration = Math.sqrt(x * x + y * y + z * z);\n  \n  if (acceleration > SHAKE_THRESHOLD) {\n    // Shake!\n  }\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Beispiel-Werte:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Normal: ",(0,s.jsx)(n.code,{children:"(0, 0, 1)"})," -> 1G nach unten"]}),"\n",(0,s.jsxs)(n.li,{children:["Shake: ",(0,s.jsx)(n.code,{children:"x=0.8, y=1.2, z=0.9"})," -> ",(0,s.jsx)(n.code,{children:"\u221a(0.64+1.44+0.81) = 1.89"})," -> Shake erkannt!"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"camera-sensor",children:"Camera (Sensor)"}),"\n",(0,s.jsx)(n.p,{children:"F\xfcr das Profilbild in den Settings:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { CameraView, useCameraPermissions } from 'expo-camera';\n\nconst [permission, requestPermission] = useCameraPermissions();\n\nconst handleTakePhoto = useCallback(async () => {\n  if (!permission) {\n    const { status } = await requestPermission();\n    if (status !== 'granted') {\n      Alert.alert('Permission Denied', 'Camera permission is required to take a profile picture.');\n      return;\n    }\n  }\n  \n  if (!permission?.granted) {\n    Alert.alert('Permission Denied', 'Camera permission is required to take a profile picture.');\n    return;\n  }\n\n  setCameraVisible(true);\n}, [permission, requestPermission]);\n\nconst handleCapture = useCallback(async () => {\n  if (cameraRef.current) {\n    try {\n      const photo = await cameraRef.current.takePictureAsync();\n      if (photo?.uri) {\n        await settingsViewModel.setProfilePicture(photo.uri);\n        setProfilePicture(photo.uri);\n        setCameraVisible(false);\n      }\n    } catch (error) {\n      console.error('Failed to take picture:', error);\n      Alert.alert('Error', 'Failed to take picture. Please try again.');\n    }\n  }\n}, [settingsViewModel]);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Die Camera UI ist ein Modal mit Cancel, Capture und Flip Buttons."}),"\n",(0,s.jsx)(n.h4,{id:"haptic-engine-aktor",children:"Haptic Engine (Aktor)"}),"\n",(0,s.jsx)(n.p,{children:"Verschiedene haptische Patterns f\xfcr verschiedene Aktionen:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import * as Haptics from 'expo-haptics';\n\nconst hapticPatterns = {\n  purchase: async () => {\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);\n  },\n  \n  gameComplete: async () => {\n    await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n  },\n  \n  error: async () => {\n    await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n  },\n  \n  tabPress: async () => {\n    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);\n  },\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Wann wird welches Pattern verwendet?"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Medium Impact:"})," Erfolgreicher Kauf"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Success Notification:"})," Spiel abgeschlossen oder Undo erfolgreich"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Notification:"})," Nicht genug Geld"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"vibration-aktor",children:"Vibration (Aktor)"}),"\n",(0,s.jsx)(n.p,{children:"F\xfcr st\xe4rkeres Feedback nutze ich zus\xe4tzlich zur Haptic Engine noch Vibration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Vibration } from 'react-native';\n\n// Einfach\nVibration.vibrate(100);\n\n// Pattern: [Vibration, Pause, Vibration, Pause, ...]\nVibration.vibrate([200, 100, 200, 100, 200, 100, 500]);\n\n// Stoppen\nVibration.cancel();\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Verwendete Patterns:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const vibrationPatterns = {\n  purchase: 100,                                      // Kurzer Pulse\n  error: [100, 50, 100],                             // Doppel-Pulse\n  gameComplete: [200, 100, 200, 100, 200, 100, 500], // Feier-Rhythmus\n  undo: 50,                                          // Sehr kurz\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Kompletter Flow:"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Shake Flow",src:t(2988).A+"",width:"276",height:"662"})}),"\n",(0,s.jsx)(n.h3,{id:"5-persistente-datenspeicherung",children:"5. Persistente Datenspeicherung"}),"\n",(0,s.jsx)(n.p,{children:"AsyncStorage speichert die Daten lokal auf dem Ger\xe4t als JSON."}),"\n",(0,s.jsx)(n.h4,{id:"speichern",children:"Speichern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/viewmodels/GameViewModel.ts\n\nasync saveGameState(): Promise<void> {\n  try {\n    // Dates zu ISO Strings konvertieren\n    const gameStateToSave = {\n      ...this.gameState,\n      startTime: this.gameState.startTime.toISOString(),\n      endTime: this.gameState.endTime?.toISOString(),\n    };\n    \n    // Als JSON speichern\n    const jsonValue = JSON.stringify(gameStateToSave);\n    await AsyncStorage.setItem('@gameState', jsonValue);\n    \n    console.log('Game state saved successfully');\n  } catch (e) {\n    console.error('Failed to save game state', e);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"laden",children:"Laden"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async loadGameState(): Promise<void> {\n  try {\n    const jsonValue = await AsyncStorage.getItem('@gameState');\n    \n    if (jsonValue != null) {\n      const loadedState = JSON.parse(jsonValue);\n      \n      // ISO Strings zur\xfcck zu Dates konvertieren\n      this.gameState = {\n        ...loadedState,\n        startTime: new Date(loadedState.startTime),\n        endTime: loadedState.endTime ? new Date(loadedState.endTime) : undefined,\n      };\n      \n      console.log('Game state loaded successfully');\n    }\n  } catch (e) {\n    console.error('Failed to load game state', e);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h4,{id:"gespeicherte-daten",children:"Gespeicherte Daten"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["Game State (",(0,s.jsx)(n.code,{children:"@gameState"}),"):"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "currentBudget": 99999997800,\n  "purchasedItems": [\n    {\n      "id": "big_mac",\n      "name": "Big Mac",\n      "price": 2,\n      "category": "food",\n      "description": "McDonald\'s signature burger"\n    }\n  ],\n  "totalSpent": 2200,\n  "gameCompleted": false,\n  "startTime": "2025-10-04T10:30:00.000Z",\n  "endTime": null\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["Statistics (",(0,s.jsx)(n.code,{children:"@gameStatistics"}),"):"]})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "gamesPlayed": 3,\n  "fastestCompletion": 245,\n  "averageItemsPerGame": 12.3,\n  "favoriteCategory": "technology",\n  "totalMoneySpent": 300000000000,\n  "totalItemsPurchased": 37,\n  "mostExpensiveItem": {\n    "id": "nba_team",\n    "name": "NBA Team",\n    "price": 2120000000,\n    "category": "business"\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"auto-save",children:"Auto-Save"}),"\n",(0,s.jsx)(n.p,{children:"Nach jeder Aktion wird automatisch gespeichert:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"purchaseItem(item: PurchaseItem): boolean {\n  if (this.gameState.currentBudget >= item.price) {\n    // State updaten\n    this.gameState.currentBudget -= item.price;\n    this.gameState.purchasedItems.push({ ...item });\n    \n    // Automatisch speichern\n    this.saveGameState();\n    this.saveStatistics();\n    \n    this.notifyChange();\n    return true;\n  }\n  return false;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Dadurch geht kein Fortschritt verloren wenn die App geschlossen wird."}),"\n",(0,s.jsx)(n.h4,{id:"beispiel-flow",children:"Beispiel-Flow"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. App startet (erste Nutzung):"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"App startet",src:t(2778).A+"",width:"276",height:"262"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. User kauft Items:"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Kauf",src:t(3099).A+"",width:"276",height:"352"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. App wird geschlossen und neu ge\xf6ffnet:"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"App geschlossen",src:t(3264).A+"",width:"276",height:"352"})}),"\n",(0,s.jsx)(n.h4,{id:"daten-zur\xfccksetzen",children:"Daten zur\xfccksetzen"}),"\n",(0,s.jsx)(n.p,{children:"In den Settings kann man alles l\xf6schen:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"async clearAllData(): Promise<void> {\n  try {\n    await AsyncStorage.multiRemove(['@gameState', '@gameStatistics']);\n    console.log('All data cleared');\n    \n    // Reset in-memory State\n    this.gameState = {\n      currentBudget: 100000000000,\n      purchasedItems: [],\n      totalSpent: 0,\n      gameCompleted: false,\n      startTime: new Date(),\n    };\n    \n    this.notifyChange();\n  } catch (e) {\n    console.error('Failed to clear data', e);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"kritische-beurteilung",children:"Kritische Beurteilung"}),"\n",(0,s.jsx)(n.h3,{id:"the-good",children:"The good"}),"\n",(0,s.jsx)(n.p,{children:"Die MVVM-Architektur funktioniert wirklich gut. Views und Logik sind sauber getrennt, das Observer Pattern sorgt f\xfcr automatische Updates, und durch BaseViewModel muss ich den Subscribe-Mechanismus nur einmal implementieren. Die Navigation mit Expo Router ist elegant - die Ordnerstruktur definiert automatisch die Routes, und durch den Context k\xf6nnen alle Tabs auf die gleichen ViewModels zugreifen ohne Props durch mehrere Ebenen durchzureichen."}),"\n",(0,s.jsx)(n.p,{children:'Die Shake-to-Undo Funktion ist das Highlight. Der Accelerometer-Algorithmus mit 1.5G Threshold und 1-Sekunden Cooldown funktioniert zuverl\xe4ssig und f\xfchlt sich nat\xfcrlich an. Das haptische Feedback macht einen riesigen Unterschied - die verschiedenen Patterns (Light, Medium, Success, Error) sind gut unterscheidbar und machen die App "f\xfchlbar".'}),"\n",(0,s.jsx)(n.p,{children:"Die Persistenz mit AsyncStorage ist simpel aber robust. Auto-Save nach jeder Aktion bedeutet kein Datenverlust, und die JSON-Struktur l\xe4sst sich leicht erweitern. Das Offline-First Design ist perfekt f\xfcr eine Mobile App."}),"\n",(0,s.jsx)(n.h3,{id:"the-bad",children:"The bad"}),"\n",(0,s.jsxs)(n.p,{children:["Bei der MVVM-Architektur habe ich keine Dependency Injection implementiert - ViewModels werden einfach mit ",(0,s.jsx)(n.code,{children:"new"})," erstellt. Das macht Unit-Testing schwieriger, weil ich die Dependencies nicht mocken kann. In einem gr\xf6sseren Projekt w\xfcrde ich ein DI-Framework nutzen."]}),"\n",(0,s.jsx)(n.p,{children:"Die Gestiksteuerung ist relativ basic. Ich habe nur Tap, Shake und Scroll - Swipe-to-Delete, Long-Press oder Pinch-to-Zoom fehlen. Das w\xe4re cool zu haben, war aber nicht im Scope. Der Accelerometer l\xe4uft nur wenn die MainGameView aktiv ist (durch useEffect cleanup), aber mit 10 Hz Update-Rate kann das trotzdem die Batterie belasten. In einer Production-App w\xfcrde ich die Update-Rate reduzieren wenn keine Interaktion stattfindet."}),"\n",(0,s.jsx)(n.p,{children:"Die Kamera-Funktion ist sehr simpel - nur Foto aufnehmen, keine Filter, kein Zoom, keine Galerie-Integration. F\xfcr ein Profilbild reicht es, aber mehr Features w\xe4ren nice."}),"\n",(0,s.jsx)(n.p,{children:"Die Persistenz ist rein lokal ohne Cloud-Sync. Wenn jemand die App deinstalliert oder das Ger\xe4t wechselt, sind alle Daten weg. AsyncStorage hat auch keine Schema-Versionierung - wenn sich die Datenstruktur \xe4ndert, m\xfcsste ich manuell migrieren. F\xfcr sehr viele Items w\xe4re SQLite performanter."}),"\n",(0,s.jsx)(n.h2,{id:"fazit",children:"Fazit"}),"\n",(0,s.jsx)(n.p,{children:"Die Implementierung erf\xfcllt alle Anforderungen von HZ3:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"MVVM-Architektur sauber implementiert mit Observer Pattern"}),"\n",(0,s.jsx)(n.li,{children:"Navigation mit Expo Router und Shared Context funktioniert einwandfrei"}),"\n",(0,s.jsx)(n.li,{children:"Gestiksteuerung (Touch + Shake) ist intuitiv und funktional"}),"\n",(0,s.jsx)(n.li,{children:"2 Sensoren: Accelerometer (Shake) + Camera (Profilbild)"}),"\n",(0,s.jsx)(n.li,{children:"2 Aktoren: Haptic Engine + Vibration mit differenzierten Patterns"}),"\n",(0,s.jsx)(n.li,{children:"Persistenz mit AsyncStorage und Auto-Save ist zuverl\xe4ssig"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},9343:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/Screenshot-settings-24600f0f91b5fb906a17b7310dcf3d3b.png"},9507:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/Screenshot-stats-01a235386623104b0ffbbaa6c46c01bf.png"}}]);